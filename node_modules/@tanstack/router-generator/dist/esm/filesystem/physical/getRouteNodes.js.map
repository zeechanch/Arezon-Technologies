{"version":3,"file":"getRouteNodes.js","sources":["../../../../src/filesystem/physical/getRouteNodes.ts"],"sourcesContent":["import path from 'node:path'\nimport * as fsp from 'node:fs/promises'\nimport {\n  determineInitialRoutePath,\n  removeExt,\n  replaceBackslash,\n  routePathToVariable,\n} from '../../utils'\nimport { getRouteNodes as getRouteNodesVirtual } from '../virtual/getRouteNodes'\nimport { loadConfigFile } from '../virtual/loadConfigFile'\nimport { logging } from '../../logger'\nimport { rootPathId } from './rootPathId'\nimport type {\n  VirtualRootRoute,\n  VirtualRouteSubtreeConfig,\n} from '@tanstack/virtual-file-routes'\nimport type { FsRouteType, GetRouteNodesResult, RouteNode } from '../../types'\nimport type { Config } from '../../config'\n\nconst disallowedRouteGroupConfiguration = /\\(([^)]+)\\).(ts|js|tsx|jsx)/\n\nconst virtualConfigFileRegExp = /__virtual\\.[mc]?[jt]s$/\nexport function isVirtualConfigFile(fileName: string): boolean {\n  return virtualConfigFileRegExp.test(fileName)\n}\n\nexport async function getRouteNodes(\n  config: Pick<\n    Config,\n    | 'routesDirectory'\n    | 'routeFilePrefix'\n    | 'routeFileIgnorePrefix'\n    | 'routeFileIgnorePattern'\n    | 'disableLogging'\n    | 'routeToken'\n    | 'indexToken'\n    | 'experimental'\n  >,\n  root: string,\n): Promise<GetRouteNodesResult> {\n  const { routeFilePrefix, routeFileIgnorePrefix, routeFileIgnorePattern } =\n    config\n\n  const logger = logging({ disabled: config.disableLogging })\n  const routeFileIgnoreRegExp = new RegExp(routeFileIgnorePattern ?? '', 'g')\n\n  const routeNodes: Array<RouteNode> = []\n  const allPhysicalDirectories: Array<string> = []\n\n  async function recurse(dir: string) {\n    const fullDir = path.resolve(config.routesDirectory, dir)\n    let dirList = await fsp.readdir(fullDir, { withFileTypes: true })\n\n    dirList = dirList.filter((d) => {\n      if (\n        d.name.startsWith('.') ||\n        (routeFileIgnorePrefix && d.name.startsWith(routeFileIgnorePrefix))\n      ) {\n        return false\n      }\n\n      if (routeFilePrefix) {\n        if (routeFileIgnorePattern) {\n          return (\n            d.name.startsWith(routeFilePrefix) &&\n            !d.name.match(routeFileIgnoreRegExp)\n          )\n        }\n\n        return d.name.startsWith(routeFilePrefix)\n      }\n\n      if (routeFileIgnorePattern) {\n        return !d.name.match(routeFileIgnoreRegExp)\n      }\n\n      return true\n    })\n\n    const virtualConfigFile = dirList.find((dirent) => {\n      return dirent.isFile() && isVirtualConfigFile(dirent.name)\n    })\n\n    if (virtualConfigFile !== undefined) {\n      const virtualRouteConfigExport = await loadConfigFile(\n        path.resolve(fullDir, virtualConfigFile.name),\n      )\n      let virtualRouteSubtreeConfig: VirtualRouteSubtreeConfig\n      if (typeof virtualRouteConfigExport.default === 'function') {\n        virtualRouteSubtreeConfig = await virtualRouteConfigExport.default()\n      } else {\n        virtualRouteSubtreeConfig = virtualRouteConfigExport.default\n      }\n      const dummyRoot: VirtualRootRoute = {\n        type: 'root',\n        file: '',\n        children: virtualRouteSubtreeConfig,\n      }\n      const { routeNodes: virtualRouteNodes, physicalDirectories } =\n        await getRouteNodesVirtual(\n          {\n            ...config,\n            routesDirectory: fullDir,\n            virtualRouteConfig: dummyRoot,\n          },\n          root,\n        )\n      allPhysicalDirectories.push(...physicalDirectories)\n      virtualRouteNodes.forEach((node) => {\n        const filePath = replaceBackslash(path.join(dir, node.filePath))\n        const routePath = `/${dir}${node.routePath}`\n\n        node.variableName = routePathToVariable(\n          `${dir}/${removeExt(node.filePath)}`,\n        )\n        node.routePath = routePath\n        node.filePath = filePath\n      })\n\n      routeNodes.push(...virtualRouteNodes)\n\n      return\n    }\n\n    await Promise.all(\n      dirList.map(async (dirent) => {\n        const fullPath = replaceBackslash(path.join(fullDir, dirent.name))\n        const relativePath = path.posix.join(dir, dirent.name)\n\n        if (dirent.isDirectory()) {\n          await recurse(relativePath)\n        } else if (fullPath.match(/\\.(tsx|ts|jsx|js)$/)) {\n          const filePath = replaceBackslash(path.join(dir, dirent.name))\n          const filePathNoExt = removeExt(filePath)\n          const {\n            routePath: initialRoutePath,\n            originalRoutePath: initialOriginalRoutePath,\n            isExperimentalNonNestedRoute,\n          } = determineInitialRoutePath(filePathNoExt, config)\n\n          let routePath = initialRoutePath\n          let originalRoutePath = initialOriginalRoutePath\n\n          if (routeFilePrefix) {\n            routePath = routePath.replaceAll(routeFilePrefix, '')\n            originalRoutePath = originalRoutePath.replaceAll(\n              routeFilePrefix,\n              '',\n            )\n          }\n\n          if (disallowedRouteGroupConfiguration.test(dirent.name)) {\n            const errorMessage = `A route configuration for a route group was found at \\`${filePath}\\`. This is not supported. Did you mean to use a layout/pathless route instead?`\n            logger.error(`ERROR: ${errorMessage}`)\n            throw new Error(errorMessage)\n          }\n\n          const meta = getRouteMeta(routePath, config)\n          const variableName = meta.variableName\n          let routeType: FsRouteType = meta.fsRouteType\n\n          if (routeType === 'lazy') {\n            routePath = routePath.replace(/\\/lazy$/, '')\n            originalRoutePath = originalRoutePath.replace(/\\/lazy$/, '')\n          }\n\n          // this check needs to happen after the lazy route has been cleaned up\n          // since the routePath is used to determine if a route is pathless\n          if (isValidPathlessLayoutRoute(routePath, routeType, config)) {\n            routeType = 'pathless_layout'\n          }\n\n          ;(\n            [\n              ['component', 'component'],\n              ['errorComponent', 'errorComponent'],\n              ['pendingComponent', 'pendingComponent'],\n              ['loader', 'loader'],\n            ] satisfies Array<[FsRouteType, string]>\n          ).forEach(([matcher, type]) => {\n            if (routeType === matcher) {\n              logger.warn(\n                `WARNING: The \\`.${type}.tsx\\` suffix used for the ${filePath} file is deprecated. Use the new \\`.lazy.tsx\\` suffix instead.`,\n              )\n            }\n          })\n\n          routePath = routePath.replace(\n            new RegExp(\n              `/(component|errorComponent|pendingComponent|loader|${config.routeToken}|lazy)$`,\n            ),\n            '',\n          )\n\n          originalRoutePath = originalRoutePath.replace(\n            new RegExp(\n              `/(component|errorComponent|pendingComponent|loader|${config.routeToken}|lazy)$`,\n            ),\n            '',\n          )\n\n          if (routePath === config.indexToken) {\n            routePath = '/'\n          }\n\n          if (originalRoutePath === config.indexToken) {\n            originalRoutePath = '/'\n          }\n\n          routePath =\n            routePath.replace(new RegExp(`/${config.indexToken}$`), '/') || '/'\n\n          originalRoutePath =\n            originalRoutePath.replace(\n              new RegExp(`/${config.indexToken}$`),\n              '/',\n            ) || '/'\n\n          routeNodes.push({\n            filePath,\n            fullPath,\n            routePath,\n            variableName,\n            _fsRouteType: routeType,\n            _isExperimentalNonNestedRoute: isExperimentalNonNestedRoute,\n            originalRoutePath,\n          })\n        }\n      }),\n    )\n\n    return routeNodes\n  }\n\n  await recurse('./')\n\n  const rootRouteNode = routeNodes.find((d) => d.routePath === `/${rootPathId}`)\n  if (rootRouteNode) {\n    rootRouteNode._fsRouteType = '__root'\n    rootRouteNode.variableName = 'root'\n  }\n\n  return {\n    rootRouteNode,\n    routeNodes,\n    physicalDirectories: allPhysicalDirectories,\n  }\n}\n\n/**\n * Determines the metadata for a given route path based on the provided configuration.\n *\n * @param routePath - The determined initial routePath.\n * @param config - The user configuration object.\n * @returns An object containing the type of the route and the variable name derived from the route path.\n */\nexport function getRouteMeta(\n  routePath: string,\n  config: Pick<Config, 'routeToken' | 'indexToken'>,\n): {\n  // `__root` is can be more easily determined by filtering down to routePath === /${rootPathId}\n  // `pathless` is needs to determined after `lazy` has been cleaned up from the routePath\n  fsRouteType: Extract<\n    FsRouteType,\n    | 'static'\n    | 'layout'\n    | 'api'\n    | 'lazy'\n    | 'loader'\n    | 'component'\n    | 'pendingComponent'\n    | 'errorComponent'\n  >\n  variableName: string\n} {\n  let fsRouteType: FsRouteType = 'static'\n\n  if (routePath.endsWith(`/${config.routeToken}`)) {\n    // layout routes, i.e `/foo/route.tsx` or `/foo/_layout/route.tsx`\n    fsRouteType = 'layout'\n  } else if (routePath.endsWith('/lazy')) {\n    // lazy routes, i.e. `/foo.lazy.tsx`\n    fsRouteType = 'lazy'\n  } else if (routePath.endsWith('/loader')) {\n    // loader routes, i.e. `/foo.loader.tsx`\n    fsRouteType = 'loader'\n  } else if (routePath.endsWith('/component')) {\n    // component routes, i.e. `/foo.component.tsx`\n    fsRouteType = 'component'\n  } else if (routePath.endsWith('/pendingComponent')) {\n    // pending component routes, i.e. `/foo.pendingComponent.tsx`\n    fsRouteType = 'pendingComponent'\n  } else if (routePath.endsWith('/errorComponent')) {\n    // error component routes, i.e. `/foo.errorComponent.tsx`\n    fsRouteType = 'errorComponent'\n  }\n\n  const variableName = routePathToVariable(routePath)\n\n  return { fsRouteType, variableName }\n}\n\n/**\n * Used to validate if a route is a pathless layout route\n * @param normalizedRoutePath Normalized route path, i.e `/foo/_layout/route.tsx` and `/foo._layout.route.tsx` to `/foo/_layout/route`\n * @param config The `router-generator` configuration object\n * @returns Boolean indicating if the route is a pathless layout route\n */\nfunction isValidPathlessLayoutRoute(\n  normalizedRoutePath: string,\n  routeType: FsRouteType,\n  config: Pick<Config, 'routeToken' | 'indexToken'>,\n): boolean {\n  if (routeType === 'lazy') {\n    return false\n  }\n\n  const segments = normalizedRoutePath.split('/').filter(Boolean)\n\n  if (segments.length === 0) {\n    return false\n  }\n\n  const lastRouteSegment = segments[segments.length - 1]!\n  const secondToLastRouteSegment = segments[segments.length - 2]\n\n  // If segment === __root, then exit as false\n  if (lastRouteSegment === rootPathId) {\n    return false\n  }\n\n  // If segment === config.routeToken and secondToLastSegment is a string that starts with _, then exit as true\n  // Since the route is actually a configuration route for a layout/pathless route\n  // i.e. /foo/_layout/route.tsx === /foo/_layout.tsx\n  if (\n    lastRouteSegment === config.routeToken &&\n    typeof secondToLastRouteSegment === 'string'\n  ) {\n    return secondToLastRouteSegment.startsWith('_')\n  }\n\n  // Segment starts with _\n  return (\n    lastRouteSegment !== config.indexToken &&\n    lastRouteSegment !== config.routeToken &&\n    lastRouteSegment.startsWith('_')\n  )\n}\n"],"names":["getRouteNodesVirtual"],"mappings":"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"}